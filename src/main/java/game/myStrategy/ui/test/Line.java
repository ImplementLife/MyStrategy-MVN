package game.myStrategy.ui.test;

public class Line {

    /**
     * Методы для поиска пересечения двух прямых
     *
     * Первый способ: ориентированная площадь треугольника
     * Воспользуемся Ориентированной площадью треугольника и предикат 'По часовой стрелке'.
     * Действительно, чтобы отрезки AB и CD пересекались, необходимо и достаточно,
     * чтобы точки A и B находились по разные стороны прямой CD, и, аналогично,
     * точки C и D — по разные стороны прямой AB.
     *
     * Проверить это можно, вычисляя ориентированные площади соответствующих треугольников и сравнивая их знаки.
     *
     * Единственное, на что следует обратить внимание — граничные случаи,
     * когда какие-то точки попадают на саму прямую.
     * При этом возникает единственный особый случай, когда вышеописанные проверки ничего не дадут
     * — случай, когда оба отрезка лежат на одной прямой.
     * Этот случай надо рассмотреть отдельно. Для этого достаточно проверить,что проекции
     * этих двух отрезков на оси X и Y пересекаются (часто эту проверку называют "проверкой на bounding box").
     *
     * В целом, этот способ — более простой, чем тот, что будет приведён ниже
     * (производящий пересечение двух прямых), и имеет меньше особых случаев,
     * однако главный его недостаток — в том, что он не находит саму точку пересечения.
     *
     * В целях оптимизации проверка на bounding box вынесена в начало, до вычисления площадей — поскольку это более "лёгкая" проверка.
     *
     * Само собой, этот код применим и для случая вещественных координат,
     * просто все сравнения с нулём следует производить по эпсилону
     * (и избегать перемножения двух вещественнозначных значений \rm area(), перемножая вместо этого их знаки).
     *
     * Ссылка на статью: https://e-maxx.ru/algo/segments_intersection_checking
     */

    private static class Pt {
        public Pt(double x, double y) {
            this.x = x;
            this.y = y;
        }
        double x, y;

        public boolean operator(Pt p) {
            return x < p.x-EPS || Math.abs(x-p.x) < EPS && y < p.y - EPS;
        }

        public double getX() {
            return x;
        }

        public void setX(double x) {
            this.x = x;
        }

        public double getY() {
            return y;
        }

        public void setY(double y) {
            this.y = y;
        }
    };

    private static double area (Pt a, Pt b, Pt c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    }

//    private static boolean intersect (Pt a, Pt b, Pt c, Pt d) {
//        return intersect_1 (a.x, b.x, c.x, d.x)
//                && intersect_1 (a.y, b.y, c.y, d.y)
//                && area(a,b,c) * area(a,b,d) <= 0
//                && area(c,d,a) * area(c,d,b) <= 0;
//    }


    /**
     * Второй способ: пересечение двух прямых
     * Вместо пересечения отрезков выполним пересечение двух прямых,
     * в результате, если прямые не параллельны, получим какую-то точку,
     * которую надо проверить на принадлежность обоим отрезкам; для этого достаточно проверить,
     * что эта точка принадлежит обоим отрезкам в проекции на ось X и на ось Y.
     *
     * Если же прямые оказались параллельными, то, если они не совпадают,
     * то отрезки точно не пересекаются. Если же прямые совпали, то отрезки лежат на одной прямой,
     * и для проверки их пересечения достаточно проверить, что пересекаются их проекции на ось X и Y.
     *
     * Остаётся ещё особый случай, когда один или оба отрезка вырождаются в точки:
     * в таком случае говорить о прямых некорректно, и этот метод будет неприменим
     * (этот случай надо будет разбирать отдельно).
     *
     * Реализация (без учёта случая вырожденных отрезков):
     *
     *
     *
     * Здесь сначала вычисляется коэффициент \rm zn — знаменатель в формуле Крамера.
     * Если {\rm zn} = 0, то коэффициенты A и B прямых пропорциональны, и прямые параллельны или совпадают.
     * В этом случае надо проверить, совпадают они или нет, для чего надо проверить,
     * что коэффициенты C прямых пропорциональны с тем же коэффициентом,
     * для чего достаточно вычислить два следующих определителя,
     * если они оба равны нулю, то прямые совпадают:
     *
     *  \left|\matrix{ A_1 & C_1 \cr A_2 & C_2 }\right|, [...]
     *
     * Если же {\rm zn} \ne 0, то прямые пересекаются,
     * и по формуле Крамера находим точку пересечения (x,y) и проверяем её принадлежность обоим отрезкам.
     *
     * Следует отметить, что если исходные координаты точек уже были вещественнозначными,
     * то следует нормировать прямые
     * (т.е. привести их к такому состоянию, что сумма квадратов коэффициентов a и b равна единице),
     * иначе погрешности при сравнении прямых на параллельность и на совпадение могут оказаться слишком большими.
     *
     * Ссылка на статью: https://e-maxx.ru/algo/segments_intersection_checking
     */

    private static final double EPS = 1E-9;

    private static double det (double a, double b, double c, double d) {
        return a * d - b * c;
    }

    private static boolean intersect (Pt a, Pt b, Pt c, Pt d) {
        double A1 = a.y-b.y,  B1 = b.x-a.x,  C1 = -A1*a.x - B1*a.y;
        double A2 = c.y-d.y,  B2 = d.x-c.x,  C2 = -A2*c.x - B2*c.y;
        double zn = det (A1, B1, A2, B2);
        if (zn != 0) {
            double x = - det (C1, B1, C2, B2) * 1. / zn;
            double y = - det (A1, C1, A2, C2) * 1. / zn;
            return between (a.x, b.x, x) && between (a.y, b.y, y)
                    && between (c.x, d.x, x) && between (c.y, d.y, y);
        }
        else
            return det (A1, C1, A2, C2) == 0 && det (B1, C1, B2, C2) == 0
                    && intersect_1 (a.x, b.x, c.x, d.x)
                    && intersect_1 (a.y, b.y, c.y, d.y);
    }

    ///////////////////////////////////////////////////
    //////////////////////////////////////////////////
    /////////////////////////////////////////////////
    ////////////////////////////////////////////////
    ///////////////////////////////////////////////
    //////////////////////////////////////////////
    /////////////////////////////////////////////
    ////////////////////////////////////////////
    ///////////////////////////////////////////
    //////////////////////////////////////////
    /////////////////////////////////////////
    ////////////////////////////////////////
    ///////////////////////////////////////
    //////////////////////////////////////
    /////////////////////////////////////
    ////////////////////////////////////
    /**
     * Пересечение двух отрезков
     * Даны два отрезка AB и CD (они могут вырождаться в точки). Требуется найти их пересечение: оно может быть пустым (если отрезки не пересекаются), может быть одной точкой, и может быть целым отрезком (если отрезки накладываются друг на друга).
     *
     * Алгоритм
     * Работать с отрезками будем как с прямыми: построим по двум отрезкам уравнения их прямых, проверим, не параллельны ли прямые. Если прямые не параллельны, то всё просто: находим их точку пересечения и проверяем, что она принадлежит обоим отрезкам (для этого достаточно проверить, что точка принадлежит каждому отрезку в проекции на ось X и на ось Y по отдельности). В итоге в этом случае ответом будет либо "пусто", либо единственная найденная точка.
     *
     * Более сложный случай — если прямые оказались параллельными (сюда же относится случай, когда один или оба отрезка выродились в точки). В этом случае надо проверить, что оба отрезка лежат на одной прямой (или, в случае когда они оба вырождены в точку — что эта точка совпадает). Если это не так, то ответ — "пусто". Если это так, то ответ — это пересечение двух отрезков, лежащих на одной прямой, что реализуется достаточно просто — надо взять максимум из левых концов и минимум из правых концов.
     *
     * В самом начале алгоритма напишем так называемую "проверку на bounding box" — во-первых, она необходима для случая, когда два отрезка лежат на одной прямой, а во-вторых, она, как легковесная проверка, позволяет алгоритму работать в среднем быстрее на случайных тестах.
     *
     * Реализация
     * Приведём здесь полную реализацию, включая все вспомогательные функции по работе с точками и прямыми.
     *
     *
     * Главной здесь является функция \rm intersect, которая пересекает два переданных ей отрезка, и если они пересекаются хотя бы по одной точке, то возвращает \rm true, а в аргументах \rm left и \rm right возвращает начало и конец отрезка-ответа (в частности, когда ответ — это единственная точка, возвращаемые начало и конец будут совпадать).
     * Ссылка на статью: https://e-maxx.ru/algo/segments_intersection
     */

    private static class Vec3D {
        double a, b, c;
        Vec3D(Pt p, Pt q) {
            a = p.getY() - q.getY();
            b = q.getX() - p.getX();
            c = - a * p.getX() - b * p.getY();

            double z = Math.sqrt (a*a + b*b);
            if (Math.abs(z) > EPS) {
                a /= z;
                b /= z;
                c /= z;
            }
        }
        double dist (Pt p) {
            return a * p.getX() + b * p.getY() + c;
        }
    };

    //|||||||||||||||||||||||||||||||

    private static boolean intersect (Pt a, Pt b, Pt c, Pt d, Pt left, Pt right) {
        if (! intersect_1(a.x, b.x, c.x, d.x) || ! intersect_1(a.y, b.y, c.y, d.y)) {
            return false;
        }

        Vec3D m = new Vec3D(a, b);
        Vec3D n = new Vec3D(c, d);
        double zn = det (m.a, m.b, n.a, n.b);
        if (Math.abs (zn) < EPS) {
            if (Math.abs (m.dist (c)) > EPS || Math.abs (n.dist (a)) > EPS) return false;

//            if (b < a)  swap (a, b);
//            if (d < c)  swap (c, d);
//            left = Math.max (a, c);
//            right = Math.min (b, d);
            return true;
        }
        else {
            left.x = right.x = - det (m.c, m.b, n.c, n.b) / zn;
            left.y = right.y = - det (m.a, m.c, n.a, n.c) / zn;
            return between(a.x, b.x, left.x)
                    && between(a.y, b.y, left.y)
                    && between(c.x, d.x, left.x)
                    && between(c.y, d.y, left.y);
        }
    }


    /**
     * Общие методы
     */

    private static boolean between (double a, double b, double c) {
        return Math.min(a,b) <= c + EPS && c <= Math.max(a,b) + EPS;
    }

    private static boolean intersect_1 (double a, double b, double c, double d) {
        if (a > b) {
            double tempA = a;
            a = b;
            b = tempA;
        }
        if (c > d) {
            double tempC = c;
            c = d;
            d = tempC;
        }
        return Math.max(a,c) <= Math.min(b,d);
    }


}
